from sqlalchemy import create_engine, Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, declarative_base, sessionmaker
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

# Create a SQLite database engine
DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(DATABASE_URL)

# Create a SQLAlchemy session
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create a declarative base
Base = declarative_base()

# Define the SQLAlchemy models
class Customer(Base):
    __tablename__ = "Customer"

    custid = Column(Integer, primary_key=True, index=True)
    lastname = Column(String)
    firstname = Column(String)
    idf_proof = Column(String)
    idnumber = Column(String)
    phone_number_id = Column(Integer, ForeignKey('PHONENUMBER.phone_number'))
    address = Column(String)
    dob = Column(String)
    phone_number = relationship("PhoneNumber", back_populates="customer")

class Tickets(Base):
    __tablename__ = "Tickets"

    Ticketid = Column(Integer, primary_key=True, index=True)
    phone_number_id = Column(Integer, ForeignKey('PHONENUMBER.phone_number'))
    custid = Column(Integer, ForeignKey('Customer.custid'))
    staffid = Column(Integer, ForeignKey('Staff.staffid'))
    TicketStatus = Column(String)
    Description = Column(String)

class Staff(Base):
    __tablename__ = "Staff"

    staffid = Column(Integer, primary_key=True, index=True)
    address = Column(String)
    idproof = Column(String)
    idnumber = Column(String)
    firstname = Column(String)
    lastname = Column(String)

class PhoneNumber(Base):
    __tablename__ = "PHONENUMBER"

    phone_number = Column(Integer, primary_key=True, index=True)
    type = Column(String)
    plan = Column(String)
    customer = relationship("Customer", back_populates="phone_number")

class Bill(Base):
    __tablename__ = "Bill"

    Billid = Column(Integer, primary_key=True, index=True)
    phone_number_id = Column(Integer, ForeignKey('PHONENUMBER.phone_number'))
    Amount = Column(Integer)

# Create tables in the database
Base.metadata.create_all(bind=engine)

# FastAPI app
app = FastAPI()

# Pydantic models for input and output
class CustomerCreate(BaseModel):
    lastname: str
    firstname: str
    idf_proof: str
    idnumber: str
    phone_number_id: int
    address: str
    dob: str

class CustomerResponse(BaseModel):
    custid: int
    lastname: str
    firstname: str
    idf_proof: str
    idnumber: str
    phone_number_id: int
    address: str
    dob: str

class TicketCreate(BaseModel):
    phone_number_id: int
    custid: int
    staffid: int
    TicketStatus: str
    Description: str

class TicketResponse(BaseModel):
    Ticketid: int
    phone_number_id: int
    custid: int
    staffid: int
    TicketStatus: str
    Description: str

class StaffCreate(BaseModel):
    address: str
    idproof: str
    idnumber: str
    firstname: str
    lastname: str

class StaffResponse(BaseModel):
    staffid: int
    address: str
    idproof: str
    idnumber: str
    firstname: str
    lastname: str

class PhoneNumberCreate(BaseModel):
    type: str
    plan: str

class PhoneNumberResponse(BaseModel):
    phone_number: int
    type: str
    plan: str

class BillCreate(BaseModel):
    phone_number_id: int
    Amount: int

class BillResponse(BaseModel):
    Billid: int
    phone_number_id: int
    Amount: int

# Define FastAPI endpoints to create and retrieve data
@app.post("/customers/", response_model=CustomerResponse)
def create_customer(customer: CustomerCreate):
    db = SessionLocal()
    db_customer = Customer(**customer.dict())
    db.add(db_customer)
    db.commit()
    db.refresh(db_customer)
    db.close()
    return db_customer

@app.post("/tickets/", response_model=TicketResponse)
def create_ticket(ticket: TicketCreate):
    db = SessionLocal()
    db_ticket = Tickets(**ticket.dict())
    db.add(db_ticket)
    db.commit()
    db.refresh(db_ticket)
    db.close()
    return db_ticket

@app.post("/staff/", response_model=StaffResponse)
def create_staff(staff: StaffCreate):
    db = SessionLocal()
    db_staff = Staff(**staff.dict())
    db.add(db_staff)
    db.commit()
    db.refresh(db_staff)
    db.close()
    return db_staff

@app.post("/phone_numbers/", response_model=PhoneNumberResponse)
def create_phone_number(phone_number: PhoneNumberCreate):
    db = SessionLocal()
    db_phone_number = PhoneNumber(**phone_number.dict())
    db.add(db_phone_number)
    db.commit()
    db.refresh(db_phone_number)
    db.close()
    return db_phone_number

@app.post("/bills/", response_model=BillResponse)
def create_bill(bill: BillCreate):
    db = SessionLocal()
    db_bill = Bill(**bill.dict())
    db.add(db_bill)
    db.commit()
    db.refresh(db_bill)
    db.close()
    return db_bill

@app.get("/customers/{custid}", response_model=CustomerResponse)
def read_customer(custid: int):
    db = SessionLocal()
    customer = db.query(Customer).filter(Customer.custid == custid).first()
    db.close()
    return customer

@app.get("/tickets/{Ticketid}", response_model=TicketResponse)
def read_ticket(Ticketid: int):
    db = SessionLocal()
    ticket = db.query(Tickets).filter(Tickets.Ticketid == Ticketid).first()
    db.close()
    return ticket

@app.get("/staff/{staffid}", response_model=StaffResponse)
def read_staff(staffid: int):
    db = SessionLocal()
    staff = db.query(Staff).filter(Staff.staffid == staffid).first()
    db.close()
    return staff

@app.get("/phone_numbers/{phone_number}", response_model=PhoneNumberResponse)
def read_phone_number(phone_number: int):
    db = SessionLocal()
    phone_number = db.query(PhoneNumber).filter(PhoneNumber.phone_number == phone_number).first()
    db.close()
    return phone_number

@app.get("/bills/{Billid}", response_model=BillResponse)
def read_bill(Billid: int):
    db = SessionLocal()
    bill = db.query(Bill).filter(Bill.Billid == Billid).first()
    db.close()
    return bill

@app.get("/customers/", response_model=List[CustomerResponse])
def read_customers(skip: int = 0, limit: int = 100):
    db = SessionLocal()
    customers = db.query(Customer).offset(skip).limit(limit).all()
    db.close
